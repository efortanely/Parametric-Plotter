# Parametric-Plotter
Overview.

This project contains tools for graphing a number of three-dimensional parametric surfaces in a scene that can be freely rotated. There are options to define parameters for built in functions, including torus knots or spheres, as well as the ability to define custom equations in the ‘Runner’ class, which is the program the user should run to see the graphed objects! The torus knot class is created by using numerical differentiation of the torus equation to approximate a torus around the knot, and storing these points as coordinates. At initial creation of each object, their three-dimensional coordinates are generated and stored. All of the objects in the scene are in an ArrayList of Graph objects in the Runner. During the render phase, if the viewing vector has moved due to user input or if the initial scene needs to be created, then a new set of polygons is generated from the pre-computed three-dimensional objects to compose the render scene, otherwise, the program renders the two-dimensional polygons already created, as no change has occurred logically. This speeds up the processing time significantly by not regenerating the polygons each frame, if unnecessary. The new set of polygons is created by making an ArrayList of Plane objects, iterating through each three-dimensional object in the scene, and adding all of its new two-dimensional planes that face the camera created relative to this new viewing angle, as well as their distance from the viewer, to the ArrayList. Back-face culling is implemented to only store the two-dimensional polygons that face the viewer. A color is associated with each plane by means of flat shading, by computing the difference between the camera angle and the normal of the plane. To render the scene to the viewer, the planes are stored in a Plane array, then sorted from furthest distance from camera, to closest distance to camera. This is Painter’s algorithm, which crudely renders three-dimensional scenes by simply painting over objects behind the objects in front of them. This algorithm is not the best for rendering three-dimensional scenes, as there are a number of edge cases, such as when objects may be intersecting, or both in front of and behind another object, that this does not account for. If I were to reimplement this project, I would include a more rigorous method of shading, such as interpolating between colors associated with each vertex of the plane’s faces in order to create a smooth gradient on the object, rather than setting a single color for each plane. Additionally, I would create a better abstraction for the camera method, as there are currently two ‘viewing vectors’—one used for rendering the coordinates, and one used to define the camera angle of the viewer, and the combination of both of these in the program is hard to follow.

The Runner class.

This class extends the Engine and defines the main structure of the program. A number of pre-defined functions exist here, and can also be defined by the user by creating a new functor with the desired equation, then creating an associated Graph object by passing it the functor. This object can then be added to the ArrayList of objects, which will be drawn during the render phase. During the game loop, the camera angles are updated based on user IO, then all objects are rendered, by calling the static ‘renderAll’ method in the Renderer.

The Renderer class.

This class is an intermediary between the Runner class and the Plane class, implemented to abstract the rendering process from the Runner class. A value representing the camera distance from the object is created during the first frame, and used for calculation in all other frames, by multiplying 10 by the maximum distance of the objects in the scene from the origin. This is for use in the Painter’s algorithm, to create a vector that is arbitrarily far away from the object to act as the ‘camera’. During each render phase, the Runner passes its current viewing angle to the Renderer, and this is used in rendering the planes properly. If the scene is null or the scene has changed, as indicated by a difference in camera viewing angle since the last frame, then a new Plane array is created by calling ‘renderByDistance’. Otherwise, the last Plane array is painted, avoiding unnecessary creation of two-dimensional objects if the viewing angle of the three-dimensional objects is unchanged. The ‘renderByDistance’ method creates an ArrayList of Planes, and for each object in the scene, adds all of its associated planes to this ArrayList, then sorts them from back to front with a Comparator subtracting the difference between the second Plane’s distance from the camera and the first Plane’ distance from the camera, then this array is stored and rendered.

The Plane class.

This class keeps track of the three-dimensional and two-dimensional representation of the current plane, as well as its color and distance from the viewer, which is used for rendering. Its distance from the viewer is calculated as its closest coordinate, as these objects aren’t particularly sophisticated. A cartesian polygon is created from its three-dimensional coordinates by using the viewing angle to generate its projection. Its normal is defined as the cross product between two vectors pointing between its vertices. The color is set as one minus the angle between the normal and the camera, divided by pi. This is found with the definition of the dot product, and the reason for dividing by pi is because the largest magnitude of difference in the angle between two vectors is pi.

The EquationTypes interface.

This interface contains the definitions for a general parametric function, as well as a knot and spheroid. This interface is implemented by the Runner class to allow the user to define custom functions, as well as the abstract Graph class, to allow its children to define functors representing their unique equations.

The Graph class and the associated ParametricPlot, Sphere, and TorusKnot classes.

The abstract Graph class exists as an umbrella for classes extending it, containing a number of default variables for these children, such as the default scale, polar coordinate range, and default angle step size. When the graph is first created, it iterates through its total range, and adds each coordinate, forced to be implemented by children in ‘getCoordinateAt()’, to a two-dimensional ArrayList of Vector objects, representing the coordinates of the graph. The squared distance from the outermost coordinate to the origin is stored to be used in the Renderer class to determine the distance of the camera vector. A ‘getPolygons()’ method is included, to be called by the Renderer when a two-dimensional rendering is needed. This method iterates though the graph’s pre-computed three-dimensional coordinates, creating Plane objects for each set of four vertices. These planes are preprocessed with back-face culling, which does not add to the ArrayList of Planes any plane with a normal that, if the dot product with the camera vector is negative, is removed and not added to the scene entirely, as it is facing away from the camera and implies the object is obscured by another object in front of it. All planes with positive dot products are added to an ArrayList and returned.

The ParametricPlot and sphere class do not have any sophisticated implementations.

The TorusKnot class defines a knot functor, which returns a Vector for the coordinate of a knot at a given point in space. However, this is simply an intermediary step in creating the torus knot! The torus knot functor is then defined by returning this function, plus the equation for a circle in the normal and binormal directions related to the parametric curve. This essentially means that for any point on the knot, there is an associated Frenet frame, composed of 3 vectors, one pointing along the knot, a tangent vector, one pointing normal to this tangent, a normal vector, and a vector normal to the plane created by the span of the tangent and normal vectors—a binormal vector. The Frenet frame is helpful for describing the movement of objects in space along curved trajectories. These vectors are found by doing some simple algebra, namely, the formula for finding the slope of a line between two points. Computing an accurate derivative is much too computationally expensive, and more relevant to scientific pursuits, rather than a graphics project demanding speed and approximations. For any given point on the knot, the Frenet frame is found as follows: compute the tangent by dividing the difference between a position slightly in front of the current point, and the current point, by the step size taken between the changed theta. Compute the normal by repeating this process, but instead of finding the difference between the positions, find the difference between the tangents at those associated steps. Find the binormal by finding the cross product of the tangent with the normal at that associated step. A more accurate method for approximating this is the “midpoint method”, where instead of finding the difference between the current position and one slightly in front of it, one finds the difference between a position slightly behind it and one slightly in front of the position. However, this silly project doesn’t warrant such level of precision.
